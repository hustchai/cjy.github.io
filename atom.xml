<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/cjy.github.io/atom.xml" rel="self"/>
  
  <link href="https://hustchai.github.io/cjy.github.io/"/>
  <updated>2017-12-09T11:04:09.000Z</updated>
  <id>https://hustchai.github.io/cjy.github.io/</id>
  
  <author>
    <name>chaijingyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netty源码浅析--accept</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/netty%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-accept/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/netty源码浅析-accept/</id>
    <published>2017-12-09T10:58:34.000Z</published>
    <updated>2017-12-09T11:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们分析了netty线程启动和服务器bind的过程，接着我们要分析的是服务器accept的过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先看一下java nio中是怎么处理accept这个操作的。我们截取java nio中的一个代码片段。<br><img src="http://img.blog.csdn.net/20170707190213416?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="java nio accept"><br>selector获取活跃key之后，然后会判断key是否是可accept的，如果是则执行accept操作。我们都知道netty是对java nio的封装，所以对netty的accept的分析也会从获取的活跃的key开始。</p><p>netty使用NioEventLoop来处理相应的网络事件。当有客户端connect请求，selector可以返回其对应的SelectionKey，然后对这些key进行相应的处理。（为了说明处理流程，省去与流程无关代码）<br><img src="http://img.blog.csdn.net/20170707191939763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>采用SelectedSelectionKeySet保存有事件发生的selectedKey。<br>1、SelectedSelectionKeySet内部使用两个大小为1024的SelectionKey数组keysA和keysB保存selectedKey。<br>2、把SelectedSelectionKeySet实例映射到selector的原生selectedKeys和publicSelectedKeys。</p><p><img src="http://img.blog.csdn.net/20170707192250385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="process"><br>selector会一次性的取到所有活跃的（有事件触发的）key，通过for循环来遍历所有的key。<br>通过attachment()来获取注册在ServerSocketChannel的附件，其实附件就是ServerSocketChannel本身。如果是AbstractNioChannel的实例，则调用processSelectedKey()方法。</p><p><img src="http://img.blog.csdn.net/20170707192818587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="processSelectedkey"><br>unsafe是实际操作网络I/O的类。类名字是unsafe,并不是说这个类是不安全的，而是从框架的角度上来说尽量不要使用unsafe进行网络操作。<br>方法内部会对感兴趣的操作进行判断，这里由于我们分析的accept操作，所以会调用unsafe的read方法。</p><p>该read方法是在NioMessageUnsafe类实现的。同样的为了说明主要逻辑，省略一些属性判断和设置的相关代码。<br><img src="http://img.blog.csdn.net/20170707193726434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>大家有没有想过，为什么accept方法会在一个叫read方法内部。不要忽略了 这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</span><br><span class="line">  unsafe.read();          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果是accept和read操作都会调用read方法。然后在read方法内部进行判断。doReadMessages(readBuf) 可以认为是在判断accept操作还是read操作。</p><p><img src="http://img.blog.csdn.net/20170707194449199?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="doreadmessage"><br>1、javaChannel()方法返回ServerSocketChannel实例。<br>2、ServerSocketChannel.accept方法返回socketChannel 。<br>3、把 NioServerSocketChannel 和 socketChannel 封装成 NioSocketChannel，并缓存到readBuf。<br>在调用NioSocketChannel的构造方法时会自动将read操作设置成为该channel当前感兴趣的事件。<br><img src="http://img.blog.csdn.net/20170707195510071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>至此accept操作完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前面我们分析了netty线程启动和服务器bind的过程，接着我们要分析的是服务器accept的过程。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring自定义annotation实现</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Spring%E8%87%AA%E5%AE%9A%E4%B9%89annotation%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Spring自定义annotation实现/</id>
    <published>2017-12-09T10:57:57.000Z</published>
    <updated>2017-12-09T11:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实习的时候使用了dubbo。第一次使用了Spring的自定义annotation，当时就觉得这玩意真好用，一定要学会它。经过几天的探索，终于搞清楚了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩展xml自定义标签需要如下几个步骤（自定义xml标签是自定义annotation标签的基础）</p><ul><li>编写xml schema描述自定义元素</li><li>实现namespaceHandler接口</li><li>实现BeanDefinitionParser接口</li><li><p>编写spring.handlers和spring.schemas（这俩文件必须放到META-INF文件夹下）</p><p>Spring官方文档有具体的例子，不在累述。链接：<a href="http://docs.spring.io/spring/docs/4.3.0.BUILD-SNAPSHOT/spring-framework-reference/htmlsingle/#xml-custom" target="_blank" rel="noopener">Spring 官方文档</a></p></li></ul><p>废话不多说，直接上例子</p><p><strong>整个项目的目录结构</strong><br><img src="http://img.blog.csdn.net/20170630161714064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="项目目录结构"></p><p><strong>1.编写xml schema</strong></p><p><img src="http://img.blog.csdn.net/20170630161302442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="xml schema"><br>该schema只定义了一个元素 即annotion 这个元素有两个属性id,package。package属性标识了需要扫描的annotion在哪个路径下。</p><p>applicationContext.xml<br><img src="http://img.blog.csdn.net/20170630163455465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="applicationContext.xml"></p><p><strong>2.实现namespaceHandler接口</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spring对于非默认空间下标签的解析处理都是有对应的XXXNamespaceHandler的，比如解析<aop:xxx>标签，其有一个对应的叫做AopNamespaceHandler的Handler存在，所有在aop命名空间之下的几点的解析交给该Handler处理；但我们在使用时不需要实现namespaceHandler，而可以实现spring为我们提供的NamespaceHandlerSupport，这里面封装了大量的逻辑使我们开发变得简单。<br><img src="http://img.blog.csdn.net/20170630162709438?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="namespaceHandler"></aop:xxx></p><p><strong>3实现BeanDefinitionParser接口</strong><br>Spring在解析到annotation标签时会调用AnnotationBeanDefinitionParser的parse方法解析。<br><img src="http://img.blog.csdn.net/20170630163013164?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="BeanDefinitionParser"><br>parse方法比较简单，只把applicationContext文件内配置的annotation配置的package属性读取出来，并将该属性封装到BeanDefinition内。然后将该BeanDefinition注册到容器。这在里面我们是将AnnotaionBean注册到容器中。Spring容器会实例化AnnotationBean</p><p>AnnotationBean的实现<br><img src="http://img.blog.csdn.net/20170630163921212?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="AnnotationBean"><br>AnnotationBean实现了BeanFactoryPostProcessor，BeanPostProcessor和ApplicationContextAware接口。这三个接口的作用我想大家应该都清楚吧，就不过多叙述。<br>在postProcessBeanFactory方法中，根据annotation的package属性来扫描Service注解。具体代码如上图。</p><p>然后在postProcessAfterInitialization方法中获取Service注解，并获取Service注解标记的类。具体代码如图。<br><img src="http://img.blog.csdn.net/20170630164726536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="postProcessAfterInitialization"></p><p>ServiceBean的实现<br><img src="http://img.blog.csdn.net/20170630164954550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ServiceBean"></p><p>ServiceBean的实现比较简单，只是将获取到Service注解的content属性输出和Service标记类show方法的调用。<br><img src="http://img.blog.csdn.net/20170630165148834?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="test"></p><p><strong>4.spring.handlers和spring.schemas</strong><br>如何写这两个文件，Spring官方文档写的很清楚。这里就不再展示。具体看<a href="https://github.com/hustchai/Annotation" target="_blank" rel="noopener">github</a>。</p><p>测试结果<br><img src="http://img.blog.csdn.net/20170630165256858?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzI3NTA0Njc1OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="result"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在实习的时候使用了dubbo。第一次使用了Spring的自定义annotation，当时就觉得这玩意真好用，一定要学会它。经过几天的探索，终于搞清楚了。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nb
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>基于netty的网络聊天室</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/%E5%9F%BA%E4%BA%8Enetty%E7%9A%84%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/基于netty的网络聊天室/</id>
    <published>2017-12-09T10:57:16.000Z</published>
    <updated>2017-12-09T11:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于netty和mybaties的网络聊天室</p><p>登录界面<br><img src="http://img.blog.csdn.net/20160916104145587" alt="这里写图片描述"></p><p>一对多聊天界面<br><img src="http://img.blog.csdn.net/20160916104211529" alt="这里写图片描述"></p><p>注册界面<br><img src="http://img.blog.csdn.net/20160916104247681" alt="这里写图片描述"></p><p>注册失败界面<br><img src="http://img.blog.csdn.net/20160916104313853" alt="这里写图片描述"></p><p>github:<br><a href="https://github.com/hustchai/Chat" target="_blank" rel="noopener">https://github.com/hustchai/Chat</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于netty和mybaties的网络聊天室&lt;/p&gt;
&lt;p&gt;登录界面&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160916104145587&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;一对多聊天界面&lt;br&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>daoHelper</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/daoHelper/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/daoHelper/</id>
    <published>2017-12-09T10:56:28.000Z</published>
    <updated>2017-12-09T11:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据sql语句自动生成po,dao,xml。</p><p><img src="http://img.blog.csdn.net/20160916102613485" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160916102629298" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160916102645400" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160916102658119" alt="这里写图片描述"></p><p>github:<br><a href="https://github.com/hustchai/dao-helper" target="_blank" rel="noopener">https://github.com/hustchai/dao-helper</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据sql语句自动生成po,dao,xml。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160916102613485&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>netty源码浅析--服务器bind</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/netty%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E6%9C%8D%E5%8A%A1%E5%99%A8bind/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/netty源码浅析-服务器bind/</id>
    <published>2017-12-09T10:55:45.000Z</published>
    <updated>2017-12-09T11:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上一篇我们提到服务器启动的过程，这篇我们来分析一下服务器bind的过程。</p><p><img src="http://img.blog.csdn.net/20160903135520436" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validate()方法只做了一些必要的验证。如果有特殊的验证需求，用户可以重写validate()方法。bind的主要逻辑在doBind中。根据小编阅读源码的经历总结出一点。许多方法里面只做了一些校验，而真正的逻辑全部都在do开头的方法中。</p><p><img src="http://img.blog.csdn.net/20160903140510127" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从调用的第一个方法可以看出首先是初始化和注册，那这里到底是初始化和注册什么呢?我们接着看initAndRegister()方法。</p><p><img src="http://img.blog.csdn.net/20160903141218194" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从名字中也能看出，会先创建channel。createChannel是一个抽象方法，具体的逻辑在类ServerBootstrap中实现。</p><p><img src="http://img.blog.csdn.net/20160903141639384" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next方法选中一个EventLoop初始化channel。</p><p><img src="http://img.blog.csdn.net/20160903143500579" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newChannel使用反射来创建channel。使用的是NioServerSocketChannel类。在使用反射创建channel时，会触发NioServerSocketChannel实例化。在调用父类构造函数时传入了SelectionKey.OP_ACCEPT。熟悉Java nio的朋友都知道，在使用Java nio的时候会对selector注册SelectionKey.OP_ACCEPT。难道是在父类中实现的吗？接着来看看NioServerSocketChannel父类方法。</p><p><img src="http://img.blog.csdn.net/20160903150205030" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在AbstractNioChannel类中只是对readInterestOp赋值。并没有对channel注册。刚开始看源码的时候，小编也百事不得其解。再查阅了大量的资料后，得知，Channel注册到Selector有两种方式，一种是调用Channel的register方法，第二种是设置SelectionKey的interestOps的值。netty是用了第二种方式，通过设置SelectionKey的interestOps来注册Channel关心的事情，把实际的注册延迟了。然后设置channel为非阻塞模式。channel创建完了，接着看看init又干了些什么。</p><p><img src="http://img.blog.csdn.net/20160903151141277" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面主要是设置一些属性，不再累述。主要在p.addLast()方法的匿名内部类中。</p><p><img src="http://img.blog.csdn.net/20160903155924794" alt="这里写图片描述"></p><p>在channelInitializer类中会调用channelRegistered方法。initChannel会初始化ServerBootstrapAcceptor类。再实例化的过程中会初始化类DefaultChannelHandlerContext。在Netty的编程模型中，Handler是程序猿主要关心的地方，猿可以在自定义的Handler中实现业务逻辑。在类中有这样两段代码。</p><p><img src="http://img.blog.csdn.net/20160903152757852" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是不是有点像双链表。对。Handler其实是带head和tail节点的双链表。由此可以知道，netty的ChannelPipeline包含两条线路，up、down。而这两条链路使用的是同一套handler。在javadoc中有一张图形象的说明了这个过程。</p><p><img src="http://img.blog.csdn.net/20160903154524356" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Upstream对应上行，接收到的消息、被动的状态改变，都属于Upstream。Downstream则对应下行，发送的消息、主动的状态改变，都属于Downstream。在没加入任何handler时，是这样的。</p><p><img src="http://img.blog.csdn.net/20160903155305834" alt="这里写图片描述"></p><p>将ServerBootstrapAcceptor添加到handler链后是这样的。</p><p><img src="http://img.blog.csdn.net/20160903160429948" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后会调用handler的生命周期方法fireChannelRegistered()。这就是事件驱动的具体体现。具体fireChannelRegistered()逻辑不再分析。接着是regist方法。在实现注册之前，netty先创建了channelPromise对象。这里简单说一下，netty所有的方法都是异步，而实现异步的最好方法就是使用基于回调的事件机制。而netty使用的是基于事件监听的方式，这种基于事件监听的方式要比基于回调的事件机制效率更高一点。以后的文章中会分析这种机制。</p><p><img src="http://img.blog.csdn.net/20160903162753070" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160903163451477" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netty会把regist封装成多线程任务，然后将其加入的队列中，由eventloop执行。具体的regist的业务逻辑在AbstractChannel类中。</p><p><img src="http://img.blog.csdn.net/20160903164103730" alt="这里写图片描述"><br>具体的注册逻辑不在分析，不理解的请看java nio的相关知识。</p><p><img src="http://img.blog.csdn.net/20160903164605939" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bind前面和regist差不多。也是把具体的逻辑封装成多线程任务。然后将其丢进任务队列中。tail会代理unsafe工具类进行绑定。</p><p><img src="http://img.blog.csdn.net/20160903165309385" alt="这里写图片描述"></p><p>由bind的调用栈可知，最终会Java socket进行绑定。至此服务器bind过程分析完毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上一篇我们提到服务器启动的过程，这篇我们来分析一下服务器bind的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/2016090313
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>netty源码浅析--线程启动</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/netty%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90-%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/netty源码浅析-线程启动/</id>
    <published>2017-12-09T10:55:00.000Z</published>
    <updated>2017-12-09T11:04:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直对Java高并发比较感兴趣，最近在学习netty特来记录。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提到netty首先要了解一下什么是Reactor设计模式，在网上找了一下关于Reactor设计模式的介绍，链接在文档的最下方。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《Scalable IO in Java》中讲到了一种多线程下的Reactor模式。<br><img src="http://img.blog.csdn.net/20160820144943271" alt="这里写图片描述"><br>在这种设计模式中，有一个前端mainReactor主要负责响应client的连接请求并建立连接，和一个后端subReactor。mainReactor接收client的请求之后会转接给subReactor。由subReactor负责具体的客户端请求的读写工作。这样有一个好处，subReactor可以做一些比较耗时的操作，可以减少CPU因等待IO而阻塞的时间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;知道了什么是Reactor设计模式之后，我们来看看Reactor设计模式在netty中的应用.Netty里对应mainReactor的角色叫做“Boss”，而对应subReactor的角色叫做”Worker”。Boss负责分配请求，Worker负责执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在看源码之前，要首先理解几个概念：<br><strong>EventLoopGroup:</strong>一个EventLoopGroup就是一组EventLoop。主要负责管理EventLoop的申请和释放。<br><strong>EventLoop：</strong>处理所有的IO操作。EventLoop继承了EventLoopGroup接口，可以被当做一个single的线程池看待。</p><p>源码分析从Netty版的Hello World的开始<br><img src="http://img.blog.csdn.net/20160820151519179" alt="这里写图片描述"></p><p>代码片段的前两行就是创建bossGroup和workerGroup对象。是不是感觉有点似曾相识，还记得上文我们提到的mainReactor和subReactor嘛。bossGroup起到了mainReactor的作用，workerGroup起到了subReactor的作用。</p><p>NioEventLoopGroup类继承体系如下：<br><img src="http://img.blog.csdn.net/20160820152644288" alt="这里写图片描述"><br>从图中发现，NioEventLoopGroup既然继承了Executor，是不是猜想NioEventLoopGroup是怎么优雅的使用多线程的。</p><p>NioEventLoopGroup构造函数：</p><p><img src="http://img.blog.csdn.net/20160820152927222" alt="这里写图片描述"></p><p>这里无非是对构造函数的封装，而最终调用父类MultithreadEventLoopGroup的构造函数</p><p><img src="http://img.blog.csdn.net/20160820153355814" alt="这里写图片描述"></p><p>这里会判断传进来的线程数是否是0。如果是0就使用默认的线程数。<br>默认取-Dio.netty.eventLoopThreads，如果该系统参数也没有指定，则为可用的CPU内核数 × 2。在不需要监听多端口的情况下，bossGroup只需要1个线程即可。MultithreadEventLoopGroup构造函数会显示调用MultithreadEventExecutorGroup的构造函数</p><p><img src="http://img.blog.csdn.net/20160820154947997" alt="这里写图片描述"></p><p>为了便于理解，去掉了一些验证逻辑和出错处理逻辑。<br>1.如果没有指定excutor，会先指定executor。</p><p>2.接着创建children数组，现在可以知道EventLoopGroup和EventLoop[]之间的关系。</p><p>3.通过for循环实例children数组。</p><p><img src="http://img.blog.csdn.net/20160820162430508" alt="这里写图片描述"></p><p>在SingleThreadEventExecutor构造函数中会初始化一个任务队列，netty线程一直是在死循环中去直接IO事件和非IO事件，除了IO事件，所有非IO事件都是先丢到这个任务队列中，然后在由work线程去执行。</p><p><img src="http://img.blog.csdn.net/20160820163657300" alt="这里写图片描述"></p><p>openSeletor会先创建selector选择器，这里完全是JDK NIO的Selector的使用方法，不在累述。</p><p>接着DISABLE_KEYSET_OPTIMIZATION是判断是否需要对sun.nio.ch.SelectorImpl中的selectedKeys进行优化, 不做配置的话默认需要优化。</p><p>SelectorImpl中的selectedKeys和publicSelectedKeys是个HashSet, 新的数据结构是双数组A和B, 初始大小1024, 避免了HashSet的频繁自动扩容, processSelectedKeys时先使用数组A,再一次processSelectedKeys时调用flip的切换到数组B, 如此反复 。为什么要做这些优化我也不是很清楚。</p><p><strong>参考资料：</strong><br>Reactor设计模式介绍：<br><a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html" title="Reactor设计模式介绍" target="_blank" rel="noopener">http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html</a></p><p>多线程Reactor:<br><a href="http://my.oschina.net/flashsword/blog/197963" target="_blank" rel="noopener">http://my.oschina.net/flashsword/blog/197963</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一直对Java高并发比较感兴趣，最近在学习netty特来记录。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;提到
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java中断初窥</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Java%E4%B8%AD%E6%96%AD%E5%88%9D%E7%AA%A5/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Java中断初窥/</id>
    <published>2017-12-09T10:54:08.000Z</published>
    <updated>2017-12-09T11:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Linux时我们经常可以通过在终端键入 kill quit命令，来结束指定任务。那么Java怎么让一个线程停止呢。其中的一种方法就是让线程中断，什么是中断呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在百度百科查到的解释是：<strong>指当出现需要时，CPU暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的情况，此时，CPU暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。</strong> 简单点说，就是让当前任务停止啦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中断是一种协作机制，不会要求被中断线程强制中断。而被中断线程只要在合适时机处理就可以了，但是也可以对中断请求不予理会。</p><p>在Thread类中提供了几种有关中断的方法：<br><img src="http://img.blog.csdn.net/20160603194315507" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道Thread类中有个stop方法也可以使线程停止，那么这两个方法的区别在哪呢？中断会使程序自己去处理何时响应中断，而stop方法会在代码执行的过程中直接抛出ThreadDeath错误。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍这么多了，来看看例子吧。有run1，run2两个线程。run1线程先sleep 1秒，然后在对run2线程发出中断请求。run2线程会一直输出“111111111”直到run1线程对run2发出中断请求。</p><p><strong>run1线程类</strong><br><img src="http://img.blog.csdn.net/20160603195520949" alt="这里写图片描述"></p><p><strong>run2线程类</strong><br><img src="http://img.blog.csdn.net/20160603195542090" alt="这里写图片描述"></p><p><strong>测试类</strong><br><img src="http://img.blog.csdn.net/20160603195607762" alt="这里写图片描述"></p><p><strong>测试结果</strong><br><img src="http://img.blog.csdn.net/20160603195627502" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在使用Linux时我们经常可以通过在终端键入 kill quit命令，来结束指定任务。那么Java怎么让一个线程停止呢。其中的一种方法就是让线程中断，什么是中断呢？&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java动态代理</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Java动态代理/</id>
    <published>2017-12-09T10:53:22.000Z</published>
    <updated>2017-12-09T11:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring中的AOP是基于Java动态代理实现的，那么什么是动态代理呢？既然“动态代理”有代理两个字，那么肯定和代理模式有关系喽。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代理模式是经典的23种设计模式之一。简单的说，代理模式就是为其他对象提供一种代理，以控制对这个对象的访问。对于什么是代理模式不过多进行解释。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么什么又是动态代理呢?动态代理是相对于静态代理来说的，静态代理的代理类是手工书写的或者通过工具生成，而动态代理是程序运行前不存在，在程序运行的动态生成代理类。</p><p>Java实现动态代理的一般步骤：</p><ol><li>实现要代理的接口。</li><li>实现InvocationHandler接口，对目标方法进行增加。</li><li><p>使用Proxy.newProxyInstance获取目标对象的代理对象。</p><p>直接上例子。</p></li></ol><p>创建业务接口，包含着业务可以对外提供的功能<br><img src="http://img.blog.csdn.net/20160529164629412" alt="这里写图片描述"></p><p>创建目标接口的实现类<br><img src="http://img.blog.csdn.net/20160529164800428" alt="这里写图片描述"></p><p>自定义InvocationHandler。在自定义的InvocationHandler中需要重写3个函数。<br>构造函数，将代理对象传入。<br>invoke方法，此方法中实现了AOP增强的所有逻辑。<br>getProxy方法即使用Proxy.newProxyInstance，该方法需要指定该实例的类加载器，需要实现的接口，以及处理代理实例接口调用的处理器。</p><p><img src="http://img.blog.csdn.net/20160529165538748" alt="这里写图片描述"></p><p>测试类<br><img src="http://img.blog.csdn.net/20160529165836088" alt="这里写图片描述"></p><p>测试结果<br><img src="http://img.blog.csdn.net/20160529165941487" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Spring中的AOP是基于Java动态代理实现的，那么什么是动态代理呢？既然“动态代理”有代理两个字，那么肯定和代理模式有关系喽。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nb
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之回调模式</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/设计模式之回调模式/</id>
    <published>2017-12-09T10:52:28.000Z</published>
    <updated>2017-12-09T11:01:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回调在Spring中被大量使用，那什么是回调呢?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的说，在A类中调用B类的C方法，然后B类调用A类中的D方法。方法D被称为<strong>回调方法</strong>。回调是实现异步的基础。经典的回调方式如下：</p><ul><li>Class A实现回调接口CallBack——<strong>背景1</strong></li><li>class A中包含一个class B的引用b ——<strong>背景2</strong></li><li>class B有一个参数为callback的方法f(CallBack callback) ——<strong>背景3</strong></li><li>A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C</li><li><p>然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D</p><p>介绍完了概念，那举个例子吧。客户端向服务器端发起请求并发送信息。在接收到客户端的信息后，服务器睡5秒（模拟耗时操作），5秒之后回调客户端并输出请求状态。</p></li></ul><p><strong>回调接口</strong><br><img src="http://img.blog.csdn.net/20160526173308258" alt="这里写图片描述"></p><p><strong>服务器端</strong><br><img src="http://img.blog.csdn.net/20160526173329914" alt="这里写图片描述"></p><p><strong>客户端</strong><br><img src="http://img.blog.csdn.net/20160526173351908" alt="这里写图片描述"></p><p><strong>测试程序</strong><br><img src="http://img.blog.csdn.net/20160526173620690" alt="这里写图片描述"></p><p><strong>测试结果</strong><br><img src="http://img.blog.csdn.net/20160526173650018" alt="这里写图片描述"></p><p>先输出前一二三行，五秒之后输出四五行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;回调在Spring中被大量使用，那什么是回调呢?&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;简单的说，在A类中调用B类的C方法，然后B类调用A
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析--一次HTTP请求过程</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80%E6%AC%A1HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat源码分析-一次HTTP请求过程/</id>
    <published>2017-12-09T10:51:27.000Z</published>
    <updated>2017-12-09T11:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前两篇我们分析了Tomcat服务的启动过程和Connector(连接器)。现在让我们看看一次Tomcat服务器是怎么提供HTTP服务的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文我们说到endpoint是底层处理I/O具体实现类，那么一次HTTP首先也要从这个类中开始。还是以NIOEndPoint实现类为例子。在NIOEndPoint类中有一个名为Acceptor内部类。该内部类负责接收即将到来的TCP/IP连接，并将它们分配给合适的processor处理。<br><img src="http://img.blog.csdn.net/20160508194059544" alt="这里写图片描述"><br>HTTP底层是TCP协议，Java实现TCP协议的具体的方式就是Socket连接。我相信只要了解一点Java网络编程方面的知识都会了解的，不在累述。另一个比较重要的方法是setSocketOptions()，该方法是将socket连接添加到一个缓存队列里面。这里使用的是生产者和消费者模式，如果对该模式有不了解，请看我的另一个博文，Java并发之生产者和消费者模型<a href="http://blog.csdn.net/c275046758/article/details/50492107" target="_blank" rel="noopener">http://blog.csdn.net/c275046758/article/details/50492107</a>。</p><p><img src="http://img.blog.csdn.net/20160508195039805" alt="这里写图片描述"><br>setSocketOptions方法内获得了channel。channel是java nio中的概念，有不了解的请查看Java nio的相关内容。然后在register()方法中将channel添加到缓存队列中。</p><p><img src="http://img.blog.csdn.net/20160508195546667" alt="这里写图片描述"></p><p>addEvent方法是内部类poller内的一个私有方法。为了能看的更清晰，故将这两个方法放在一起呈现。</p><p><img src="http://img.blog.csdn.net/20160508200045762" alt="这里写图片描述"></p><p>Poller类实现了Runnable接口，是一个线程类。在run方法的15-31行中具体实现了java nio的一些代码。28行继续调用了processKey方法。接着调用了processSocket()方法。<br><img src="http://img.blog.csdn.net/20160508200903815" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160508201248148" alt="这里写图片描述"></p><p>在processSocket方法中，将具体的nio连接转换成socketProcessor处理线程。这个类是一个工作线程。可以将其理解成生产者消费者模型中的消费者。然后通过executor执行这个线程。</p><p><img src="http://img.blog.csdn.net/20160508201915941" alt="这里写图片描述"></p><p>从上一篇中我们知道handler是处理协议的地方。process方法在AbstractProcessorLight中的实现。AbstractProcessorLight是一个轻量级的抽象processor实现。</p><p><img src="http://img.blog.csdn.net/20160508202857086" alt="这里写图片描述"></p><p>接着会调用service方法。看到这个方法是不是会有种莫名的激动，是不是servlet的生命周期方法service方法很像呢。别着急，让我们看看service的具体实现。</p><p><img src="http://img.blog.csdn.net/20160508203435853" alt="这里写图片描述"></p><p>在前面经过复杂的处理后，在代码的26行调用了service方法，而它的参数正好是request和response。正好是service()生命周期方法。</p><p>自己研究源码的一点心得，如有错误请批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;前两篇我们分析了Tomcat服务的启动过程和Connector(连接器)。现在让我们看看一次Tomcat服务器是怎么提供HTTP服务的。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析--Connector(连接器)</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Connector-%E8%BF%9E%E6%8E%A5%E5%99%A8/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat源码分析-Connector-连接器/</id>
    <published>2017-12-09T10:50:26.000Z</published>
    <updated>2017-12-09T11:03:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇中分析了Tomcat的启动过程。也提到了Service会启动Connector。现在让我们来看看Connector具体做了什么。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从Connector类中有两个比较重要的属性：protocolHandler(协议)和adapter(适配器)。既然是连接器，（1）需要具备接收客户端请求的连接。（2）然后将客户端的socket请求的数据，解析和包装成为Http数据格式。（3）然后将Http数据包交给容器去处理。protocolHandler完成(1)(2)，adapter完成(3)。</p><p>1.Connector构造函数<br><img src="http://img.blog.csdn.net/20160427111439328" alt="这里写图片描述"><br>在Connector构造函数中，通过反射生成protocolHandler。协议的设置在conf/server.xml中配置，通过setProtocol来赋值。</p><p>2.Connector的初始化方法。<br>在Connector调用initInternal的初始化方法。主要完成了2个操作：</p><ol><li>初始化适配器。     </li><li>初始化protocolHandler的init()方法。<br><img src="http://img.blog.csdn.net/20160427112337608" alt="这里写图片描述"><br>protocolHandler的init方法会调用父类AbstractProtocol的init方法。<br><img src="http://img.blog.csdn.net/20160427125713824" alt="这里写图片描述"><br>其父类的init()方法会调用endpoint的init方法。endpoint提供了底层的网络i/o 连接。</li></ol><p>3.Connector的Start方法。<br>介绍完Connector的Init方法，我们来看看Connector的start方法。<br><img src="http://img.blog.csdn.net/20160427130415967" alt="这里写图片描述"><br>Connector方法中调用了protoHandler的start方法。protoHandler是个接口，我们以其具体的实现类Http11NioProtocol来介绍。从类名上可以看出，该类使用的是Java nio的方式进行连接的。Http11NioProtocol会最终调用其底层的Nio实现类NioEndPoint来接收请求。<br><img src="http://img.blog.csdn.net/20160427131330642" alt="这里写图片描述"><br>至此Connector启动完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在上一篇中分析了Tomcat的启动过程。也提到了Service会启动Connector。现在让我们来看看Connector具体做了什么。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat源码分析--启动过程</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Tomcat源码分析-启动过程/</id>
    <published>2017-12-09T10:49:35.000Z</published>
    <updated>2017-12-09T11:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直使用Tomcat确不知道它的运行原理。看了源码后对它的启动过程有了一定的了解，特来记录一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先介绍一下Tomcat的架构图：<br><img src="http://img.blog.csdn.net/20160417204227221" alt="这里写图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tomcat主要有两个核心的组件，一个是Connector(连接器)和容器。所谓连接器就是当有HTTP请求到来时，连接器负责接收这个请求，然后将该请求转发到容器。容器有Engine，Host，Context，Wrapper。Engine：表示整个Catalina servlet引擎；Host:表示包含一个或多个Context容器的虚拟主机；Context:表示一个Web应用程序。一个Context可以有多个Wrapper；Wrapper:表示一个独立的servlet。一个容器可以有0个或多个低层级的子容器。例如，一般情况下，一个Context实例会有一个或多个Wrapper实例。一个Host实例中会有0个或多个Context实例。但是，Wrapper类型处于层级结构的最底层，因此，它无法再包含子容器了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般启动Tomcat会是运行startup.bat或者startup.sh文件，这两个文件最后都会调用，org.apache.catalina.startup包下面Bootstrap类的main方法。main方法具体实现如下：<br><img src="http://img.blog.csdn.net/20160427132259811" alt="这里写图片描述"></p><p>main方法先实例化了一个Bootstrap实例，接着调用了init方法。init方法是生命周期方法，以后不再累述。接着看init的具体实现。<br><img src="http://img.blog.csdn.net/20160427132449928" alt="这里写图片描述"><br>init方法，先初始化了类加载器。initClassLoaders方法具体实现如下：<br><img src="http://img.blog.csdn.net/20160427132555850" alt="这里写图片描述"><br>createClassLoader具体实现细节不再显示，有感兴趣的读者可以具体查看。该方法的具体签名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private ClassLoader createClassLoader(String name, ClassLoader parent)  throws Exception</span><br></pre></td></tr></table></figure><p>从方法签名中可以看出createClassLoader需要传入一个父加载器。从具体的代码中可以看出，commonLoader类加载器是catalinaLoader类加载器和sharedLoader类加载器的父加载器。初始化完类加载器后，使用反射机制调用org.apache.catalina.startup.Catalina类下的setParentClassLoader方法。具体代码是:</p><p><img src="http://img.blog.csdn.net/20160427132723661" alt="这里写图片描述"></p><p>因为Tomcat执行的是start操作，调用完init方法后，会执行load方法。</p><p><img src="http://img.blog.csdn.net/20160427132817195" alt="这里写图片描述"><br>load方法通过反射调用Catalina类的load方法。</p><p><img src="http://img.blog.csdn.net/20160427132915258" alt="这里写图片描述"><br>Catalina类的load方法：</p><p><img src="http://img.blog.csdn.net/20160427133058493" alt="这里写图片描述"></p><p>load方法中比较重要的方法是createStartDigester()，createStartDigester方法主要的作用就是帮我们实例化了所有的服务组件包括server,service和connect。具体的实例化方法，<br>  <img src="http://img.blog.csdn.net/20160427133517500" alt="这里写图片描述"></p><p>初始化操作完成后，接下来会执行catalina实例的start方法。</p><p>从上面加载的组件中，Tomcat会默认加载org.apache.catalina.core.StandardServer作为Server的实例类。</p><p><img src="http://img.blog.csdn.net/20160427133728237" alt="这里写图片描述"></p><p>在Server的start的方法里面会执行service的start方法。在createStartDigester()方法里面，会默认加载org.apache.catalina.core.StandardService类。会接着调用Service的start方法。<br><img src="http://img.blog.csdn.net/20160427133903254" alt="这里写图片描述"><br>service中会调用connector的start方法。至此Tomcat启动完毕</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一直使用Tomcat确不知道它的运行原理。看了源码后对它的启动过程有了一定的了解，特来记录一下。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先先介绍一下To
      
    
    </summary>
    
    
      <category term="源码解析" scheme="https://hustchai.github.io/cjy.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之AbstractQueuedSynchronizer分析</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Java%E5%B9%B6%E5%8F%91%E4%B9%8BAbstractQueuedSynchronizer%E5%88%86%E6%9E%90/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Java并发之AbstractQueuedSynchronizer分析/</id>
    <published>2017-12-09T10:48:43.000Z</published>
    <updated>2017-12-09T11:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>在并发程序中一般使用锁对共享变量进行互斥访问。在java程序中一般用synchronized关键字来实现线程对共享变量的互斥访问。而从JDK1.5以后java并发大师 <strong>Doug Lea</strong> 开发了<strong>AbstractQueuedSynchronizer</strong>（下文用AQS代替）组件，使用原生java代码实现了synchronized语义。我们通过介绍AQS最常用的<strong>ReentrantLock</strong>锁来介绍AQS。</p><p>AQS有两种模式:<strong>公平模式和非公平模式（抢占式）</strong>。在实现自定义锁时只要按照需求实现公平模式API、非公平模式API或两种模式都实现。ReentrantLock分别实现了公平模式和非公平模式。</p><p><strong>在使用公平模式时，AQS会自动生成一个FIFO队列。严格按照线程挂起的顺序获得锁使用权。</strong></p><p>猜想：既然锁有被占用和释放两种状态，那么就需要一个state字段来标识锁的状态。果不其然，<br><img src="http://img.blog.csdn.net/20160203210350302" alt="这里写图片描述"><br>以ReentrantLock公平锁为例。<br>ReentrantLock锁通常使用模式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int show() &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看lock方法源码：<br><img src="http://img.blog.csdn.net/20160203194933004" alt="Lock方法"><br>可以发现它只是简单代理了sync的lock方法。</p><p><img src="http://img.blog.csdn.net/20160203195146778" alt="这里写图片描述"><br>明显的可以看见有两种实现模式。让我们看看公平模式的lock方法实现。</p><p><img src="http://img.blog.csdn.net/20160203195515045" alt="这里写图片描述"><br>acquire()方法在AQS中实现。</p><p><img src="http://img.blog.csdn.net/20160203195702545" alt="这里写图片描述"><br>首先看tryAcquire方法。</p><p><img src="http://img.blog.csdn.net/20160203195755530" alt="这里写图片描述"><br>在AQS中，Doug Lea并没有实现该方法。而需要使用者自己实现。那让我们看看ReentrantLock 公平模式是如何实现该方法的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();  //获得当前执行线程</span><br><span class="line">            int c = getState();    //获得当前线程状态</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;  //如果当前锁没有线程使用，则当前线程将独占该锁</span><br><span class="line">                    setExclusiveOwnerThread(current);   //设置当锁的拥有者改为当前线程</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;  //ReentrantLock是可重用锁，即锁的占用者可以多次重新进入锁</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);     //使用CAS修改锁的状态</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当获得锁的使用权时会返回true，不能获得锁耳朵使用权时会返回false。当返回false时，<strong>addWaiter()</strong>方法将当前线程加入等待队列中。</p><p>等待队列如图所示：<br><img src="http://img.blog.csdn.net/20160203202330002" alt="这里写图片描述"><br>只有head结点指向的结点才能获得锁的使用权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        Node pred = tail;    //快速找到尾结点</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;    //使用CAS方式将当前结点链接到尾结点。</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);      //如果CAS操作没能将当前结点链接到尾结点说明有多个线程产生竞争。此时需要使用自旋方式将当前结点链接到尾结点。</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将当前线程接入队列后，接着就需要将当前线程挂起。即acquireQueued方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();    //获得当前结点的前驱结点</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;   //如果前驱是头结点，并成功获取锁状态</span><br><span class="line">                    setHead(node);   //则移除前驱结点，并将当前结点设置为头结点。</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;//否则，检查前驱结点的状态，看当前获取锁失败的线程是否需要挂起。</span><br><span class="line">                    parkAndCheckInterrupt())  //如果需要挂起，借助LockSupport的静态方法Park挂起当前线程。直到将其唤醒。</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)       //如果抛出异常</span><br><span class="line">                cancelAcquire(node);   //就将当前结点移除等待队列，即请求停止</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此，线程对锁的竞争告一段落。如果获取锁，则继续运行。否则进入等待队列，线程被挂起。</p><p>接下来我们看看锁的释放<br><img src="http://img.blog.csdn.net/20160203205024818" alt="这里写图片描述"></p><p>同样代理了sync的unlock方法<br><img src="http://img.blog.csdn.net/20160203205251274" alt="这里写图片描述"></p><p>首先看tryRelease()方法。<br><img src="http://img.blog.csdn.net/20160203205334337" alt="这里写图片描述"><br>同样Doug Lea未实现这个方法。查看ReentrantLock中的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;    //当前state状态 - releases值</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())  //如果当前线程不是锁的占有者则抛出异常。</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            if (c == 0) &#123;       //如果状态为0 </span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);  //就将锁占有者设置为空</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);  //设置状态</span><br><span class="line">            return free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>锁释放成功后，找到AQS的头结点并将其唤醒即可。<br><img src="http://img.blog.csdn.net/20160203210031345" alt="这里写图片描述"><br>至此锁的释放操作完成。</p><p>只是自己最近研究AQS源码的一点心得，若有不正确的地方请批评指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在并发程序中一般使用锁对共享变量进行互斥访问。在java程序中一般用synchronized关键字来实现线程对共享变量的互斥访问。而从JDK1.5以后java并发大师 &lt;strong&gt;Doug Lea&lt;/strong&gt; 开发了&lt;strong&gt;AbstractQueuedSy
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发之CAS操作</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/java%E5%B9%B6%E5%8F%91%E4%B9%8BCAS%E6%93%8D%E4%BD%9C/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/java并发之CAS操作/</id>
    <published>2017-12-09T10:47:31.000Z</published>
    <updated>2017-12-09T11:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>CAS即compare and set的缩写。常见于java.util.concurrent中，是构成concurrent包的基础。</strong></p><p>CAS有三个操作数，内存值M，旧的预期(expect)值E和更新(update)值U。在CAS操作中，只有当M==E时，才会更新U。否则什么都不做。这些操作都是原子的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    int a = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public void write() &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        if(flag) </span><br><span class="line">            i = a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在单线程环境下不会发生错误而在多线程环境下就可以能由于指令重排发生错误。一种修改方式就是使用CAS操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    int a = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    private AtomicBoolean flag = new AtomicBoolean(false);  //使用原子boolean类</span><br><span class="line"></span><br><span class="line">    public void write() &#123;</span><br><span class="line">        a = 1;</span><br><span class="line">        flag.compareAndSet(false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        if(flag.get()) </span><br><span class="line">            i = a + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或将flag用关键字volatile修饰也可以有同样的效果。详情见我的博客java并发之volatile:<br><strong><a href="http://blog.csdn.net/c275046758/article/details/50482120" target="_blank" rel="noopener">http://blog.csdn.net/c275046758/article/details/50482120</a></strong></p><p>CAS缺点：<br><strong>ABA问题。</strong> CAS操作更新的基础是如果值没有变化则更新，若有变化则不更新。但如若有一值刚开始是A，然后变为B，最后又变为A。那么CAS检查时发现它没有变化就更新了，但实际上却是已经发生了变化。<br><strong>CAS自旋。</strong>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。<br><strong>只能保证一个共享变量的原子操作。</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;CAS即compare and set的缩写。常见于java.util.concurrent中，是构成concurrent包的基础。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAS有三个操作数，内存值M，旧的预期(expect)值E和更新(update)值U。在CA
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/设计模式之原型模式/</id>
    <published>2017-12-09T10:46:29.000Z</published>
    <updated>2017-12-09T11:01:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</strong></p><p>在说什么是原型模式前首先要解释一下两个概念，<strong>深复制和浅复制</strong>。<br><strong>浅复制：</strong>复制一个对象时，基本类型字段复制其值，引用类型复制其引用。<br><strong>深复制：</strong>复制一个对象时，不仅复制对象的基本类型的字段，而且也复制引用对象的对象。</p><p>java中使用super.clone可以得到当前调用类的对象的副本。在java中需要被克隆的对象必须实现Cloneable接口，否则视为不合法，会抛出不支持克隆的异常。</p><p><strong>HomeWork类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class HomeWork implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">private String studentNum;    //学号</span><br><span class="line">private String name;         //姓名</span><br><span class="line">private HomeWorkContent homeWorkContent;  //作业内容</span><br><span class="line"></span><br><span class="line">public HomeWork() &#123;</span><br><span class="line">homeWorkContent = new HomeWorkContent(&quot;我是内容&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setInfo(String studentNum,String name) &#123;</span><br><span class="line">this.studentNum = studentNum;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHomeWorkContent(String content) &#123;</span><br><span class="line">homeWorkContent.setContent(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HomeWork clone() &#123;</span><br><span class="line">HomeWork hw= null;</span><br><span class="line">try &#123;</span><br><span class="line">hw = (HomeWork)super.clone();</span><br><span class="line">&#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return hw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;学号是: &quot; + studentNum + &quot; \n姓名是: &quot;+name + &quot;\n作业是:&quot;+homeWorkContent.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HomeWorkContent类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HomeWorkContent &#123;</span><br><span class="line"></span><br><span class="line">private String content;  </span><br><span class="line"></span><br><span class="line">public HomeWorkContent(String content) &#123;</span><br><span class="line">this.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setContent(String content) &#123;</span><br><span class="line">this.content = content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Main测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">HomeWork hw = new HomeWork();</span><br><span class="line">HomeWork h1 = hw.clone();</span><br><span class="line">h1.setInfo(&quot;111&quot;, &quot;小白&quot;);</span><br><span class="line">h1.setHomeWorkContent(&quot;我不是内容&quot;);</span><br><span class="line">h1.show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HomeWork h2 = hw.clone();</span><br><span class="line">h2.setInfo(&quot;222&quot;, &quot;小黑&quot;);</span><br><span class="line">h2.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20160125131140420" alt="这里写图片描述"></p><p>从运行结果看clone是浅复制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在说什么是原型模式前首先要解释一下两个概念，&lt;s
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之读者写者模型</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Java并发之读者写者模型/</id>
    <published>2017-12-09T10:44:31.000Z</published>
    <updated>2017-12-09T11:03:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述:<strong>设想一个飞机订票系统，其中有许多竞争的进程试图读写其中的数据。多个进程同时读取是可以接受的，但如果一个进程正在更新数据库，则所有的其他进程都不能访问数据库。即便是读操作也不行。</strong></p><p><strong>Semaphore（信号量）</strong>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.Semaphore;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">private final ReentrantLock lock ;   //定义锁</span><br><span class="line">private static int readCount = 0;    //读者的数量</span><br><span class="line">private Semaphore writeSemaphore ;   //写信号量</span><br><span class="line"></span><br><span class="line">public Main() &#123;</span><br><span class="line">lock = new ReentrantLock();</span><br><span class="line">writeSemaphore = new Semaphore(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Main main = new Main();</span><br><span class="line">Executor executors = Executors.newFixedThreadPool(4);</span><br><span class="line">executors.execute(main.new Reader());</span><br><span class="line">executors.execute(main.new Reader());</span><br><span class="line">executors.execute(main.new Writer());</span><br><span class="line">executors.execute(main.new Reader());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Reader implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">before();             //读操作之前的操作</span><br><span class="line">read();               //读操作</span><br><span class="line">after();             //读操作之后的操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void before() &#123;    //读操作之前的操作</span><br><span class="line">final ReentrantLock l = lock;</span><br><span class="line">l.lock();</span><br><span class="line">try &#123;</span><br><span class="line">if(readCount == 0) &#123;   //当有读者时，写者不能进入</span><br><span class="line">writeSemaphore.acquire(1);</span><br><span class="line">&#125;</span><br><span class="line">readCount += 1;</span><br><span class="line">System.out.println(&quot;有1位读者进入&quot;);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">l.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void read() &#123;         //读操作</span><br><span class="line">System.out.println(&quot;当前有 &quot; + readCount + &quot; 位读者&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void after() &#123;        //读操作之后的操作</span><br><span class="line">final ReentrantLock l = lock;</span><br><span class="line">l.lock();</span><br><span class="line">try &#123;</span><br><span class="line">readCount -= 1;</span><br><span class="line">System.out.println(&quot;有1位读者离开&quot; );</span><br><span class="line">if(readCount == 0)     //当读者为0时，写者才可以进入  </span><br><span class="line">writeSemaphore.release(1);</span><br><span class="line"></span><br><span class="line">&#125; finally &#123;</span><br><span class="line">l.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Writer implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">final ReentrantLock l = lock;</span><br><span class="line">l.lock();</span><br><span class="line">try &#123;</span><br><span class="line">try &#123;</span><br><span class="line">writeSemaphore.acquire(1);     //同时只有一个写者可以进入</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;写者正在写&quot;);</span><br><span class="line">writeSemaphore.release(1);</span><br><span class="line">&#125;  finally &#123;</span><br><span class="line">l.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题描述:&lt;strong&gt;设想一个飞机订票系统，其中有许多竞争的进程试图读写其中的数据。多个进程同时读取是可以接受的，但如果一个进程正在更新数据库，则所有的其他进程都不能访问数据库。即便是读操作也不行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Semaphore（信
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之生成器模式</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/设计模式之生成器模式/</id>
    <published>2017-12-09T10:43:37.000Z</published>
    <updated>2017-12-09T11:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>将一个复杂对象的创建和它的表示分离，使得同样的创建过程可以有不同的表示。</strong></p><p>应用场景：一水杯工厂要生产各式各样的水杯，无论杯子是神马造型，但都包括绳子，帽子和杯体。以此模型创建各种类型的杯子。</p><p><img src="http://img.blog.csdn.net/20160119102247921" alt="这里写图片描述"></p><p><strong>类图</strong><br><img src="http://img.blog.csdn.net/20160119102407329" alt="这里写图片描述"></p><p><strong>cup类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Cup &#123;</span><br><span class="line"></span><br><span class="line">private String string;    //绳子</span><br><span class="line">private String cap;       //帽子</span><br><span class="line">private String cupBody;   //杯体</span><br><span class="line"></span><br><span class="line">public void setString(String string) &#123;</span><br><span class="line">this.string = string;</span><br><span class="line">&#125;</span><br><span class="line">public void setCap(String cap) &#123;</span><br><span class="line">this.cap = cap;</span><br><span class="line">&#125;</span><br><span class="line">public void setCupBody(String cupBody) &#123;</span><br><span class="line">this.cupBody = cupBody;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void show() &#123;</span><br><span class="line">System.out.println(&quot;杯子生产完毕&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Builder类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class  Builder &#123;</span><br><span class="line"></span><br><span class="line">protected Cup cup = new Cup();</span><br><span class="line"></span><br><span class="line">public abstract void buildString();</span><br><span class="line"></span><br><span class="line">public abstract void buildCap();</span><br><span class="line"></span><br><span class="line">public abstract void buildCupBody();</span><br><span class="line"></span><br><span class="line">public  Cup getResult() &#123;</span><br><span class="line">return cup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ClassCup类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCup extends Builder &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void buildString() &#123;</span><br><span class="line">cup.setString(&quot;生产绳子...&quot;);</span><br><span class="line">System.out.println(&quot;生产绳子...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void buildCap() &#123;</span><br><span class="line">cup.setCap(&quot;生产帽子...&quot;);</span><br><span class="line">System.out.println(&quot;生产帽子...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void buildCupBody() &#123;</span><br><span class="line">cup.setCupBody(&quot;生产杯体...&quot;);</span><br><span class="line">System.out.println(&quot;生产杯体...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Director类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line"></span><br><span class="line">private Builder builder;</span><br><span class="line"></span><br><span class="line">public Director(Builder builder) &#123;</span><br><span class="line">this.builder = builder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void create() &#123;</span><br><span class="line">builder.buildString();</span><br><span class="line">builder.buildCap();</span><br><span class="line">builder.buildCupBody();</span><br><span class="line">builder.getResult().show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Director d = new Director(new ClassCup());</span><br><span class="line">d.create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br><img src="http://img.blog.csdn.net/20160119102716506" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;将一个复杂对象的创建和它的表示分离，使得同样的创建过程可以有不同的表示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：一水杯工厂要生产各式各样的水杯，无论杯子是神马造型，但都包括绳子，帽子和杯体。以此模型创建各种类型的杯子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之抽象工厂</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/设计模式之抽象工厂/</id>
    <published>2017-12-09T10:42:37.000Z</published>
    <updated>2017-12-09T11:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。</strong></p><p>应用场景：想必大家都玩过暴力摩托这款游戏（暴露了年龄），在游戏中赛车手可以骑行摩托和携带武器，我们假定他拿的武器是AK47（好拉风有木有）。这只是在普通的模式下，现在我们虚拟一个魔法模式。在魔法模式下赛车手骑的是扫把（对，你没有看错，是扫把）。手里拿的是魔法棒。<br><img src="http://img.blog.csdn.net/20160115115925968" alt="这里写图片描述"></p><p><strong>IabstractFactory接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IabstractFactory &#123;</span><br><span class="line"></span><br><span class="line">public IVehicle createVehicle(int i);</span><br><span class="line"></span><br><span class="line">public IWeapon createWeapon(int i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IVehicle接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IVehicle &#123;</span><br><span class="line"></span><br><span class="line">public void run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IWeapon接口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface IWeapon &#123;</span><br><span class="line"></span><br><span class="line">public void attack();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultFactory implements IabstractFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IVehicle createVehicle(int i) &#123;</span><br><span class="line">return new Moto();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IWeapon createWeapon(int i) &#123;</span><br><span class="line">return new AK47();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>魔法模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MagicFactory implements IabstractFactory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IVehicle createVehicle(int i) &#123;</span><br><span class="line"></span><br><span class="line">return new Broom();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IWeapon createWeapon(int i) &#123;</span><br><span class="line">return new MagicStick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AK47类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AK47 implements IWeapon&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void attack() &#123;</span><br><span class="line">System.out.println(&quot;AK47....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>魔法棒</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MagicStick implements IWeapon&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void attack() &#123;</span><br><span class="line">System.out.println(&quot;MagicStick .....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>摩托车类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Moto implements IVehicle&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;Moto.....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扫把类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Broom implements IVehicle&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;Broom....&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">IabstractFactory f = new MagicFactory();</span><br><span class="line">f.createVehicle(1).run();</span><br><span class="line">f.createWeapon(1).attack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong><br><img src="http://img.blog.csdn.net/20160115120709418" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：想必大家都玩过暴力摩托这款游戏（暴露了年龄），在游戏中
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java并发之生产者消费者模型</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/java%E5%B9%B6%E5%8F%91%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/java并发之生产者消费者模型/</id>
    <published>2017-12-09T10:41:12.000Z</published>
    <updated>2017-12-09T11:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>生产者和消费者模型是操作系统中经典的同步问题。该问题最早由Dijkstra提出，用以演示它提出的信号量机制。</p><p><strong>经典的生产者和消费者模型的描述是：</strong>有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，即不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区投放产品。</p><p><img src="http://img.blog.csdn.net/20160110134343236" alt="这里写图片描述"></p><p>首先我们复习一下操作系统中同步机制中应遵循的准则：</p><ol><li><strong>空闲让进</strong>：当无进程处于临界区时，应允许一个请求进入临界区的进程进入临界区；</li><li><strong>忙则等待</strong>：当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li><li><strong>有限等待</strong>：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态；</li><li><p><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”;</p><p>在生产者和消费者模型中要保证一下几点：<br><strong>1.生产者在往缓存队列中放产品时，消费者不能取产品。</strong><br><strong>2.消费者从缓存队列中取产品时，生产者不能放产品。</strong><br><strong>3.同一时刻只有一个生产者可以往缓存队列中放产品。</strong><br><strong>4.同一时刻只有一个消费者可以从缓存队列中取产品。</strong><br><strong>5.缓存队列满时生产者不能往缓存队列中放产品。</strong><br><strong>6.缓存队列为空时消费者不能从缓存队列中取产品。</strong></p></li></ol><p>本例子中的缓存队列模仿java jdk中的ArrayBlockingQueue,这是一个阻塞队列，缓存池满时会自动将生产者线程挂起，缓存池空时会自动将消费者线程挂起。</p><p>缓存池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">public class Pool&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">/**队列最长长度*/</span><br><span class="line">private  int MaxSize = 1000;</span><br><span class="line"></span><br><span class="line">/**队列默认长度*/</span><br><span class="line">private static final int defaultSize = 100;</span><br><span class="line"></span><br><span class="line">/**资源池*/</span><br><span class="line">private Object[] objs ;</span><br><span class="line"></span><br><span class="line">/**队头*/</span><br><span class="line">private int front;</span><br><span class="line"></span><br><span class="line">/**队尾*/</span><br><span class="line">private int rear;</span><br><span class="line"></span><br><span class="line">/**元素的个数*/</span><br><span class="line">private int nItems;</span><br><span class="line"></span><br><span class="line"> /** Main lock guarding all access */</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    /** Condition for waiting takes */</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    /** Condition for waiting puts */</span><br><span class="line">    private final Condition notFull;</span><br><span class="line">    </span><br><span class="line">    private int useSize = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Pool() &#123;</span><br><span class="line">this(defaultSize);</span><br><span class="line">useSize = defaultSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Pool(int size) &#123;</span><br><span class="line">if(size &lt; 0)</span><br><span class="line">throw new IndexOutOfBoundsException();</span><br><span class="line">size = size &gt; MaxSize ? MaxSize : size;</span><br><span class="line">useSize = size;</span><br><span class="line">objs = new Object[size];</span><br><span class="line">front = 0;</span><br><span class="line">rear = -1;</span><br><span class="line">nItems = 0;</span><br><span class="line"></span><br><span class="line">lock = new ReentrantLock(true);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**进队*/</span><br><span class="line">private void queue(E e) &#123;</span><br><span class="line">if(rear == useSize - 1)</span><br><span class="line">rear = -1;</span><br><span class="line">objs[++rear] = e;</span><br><span class="line">nItems++;</span><br><span class="line">notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**出队*/</span><br><span class="line">private E dequeue() &#123;</span><br><span class="line">E e = (E)objs[front++];</span><br><span class="line">if(front == useSize)</span><br><span class="line">front = 0;</span><br><span class="line">nItems--;</span><br><span class="line">notFull.signal();</span><br><span class="line">return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**进队 资源池满会将入队线程挂起*/ </span><br><span class="line">public void offer(E e) throws InterruptedException &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">while(nItems == objs.length) </span><br><span class="line">notFull.await();</span><br><span class="line">queue(e);</span><br><span class="line">System.out.println(&quot;学生进队，当前池中有 &quot; + nItems + &quot; 名同学&quot; );</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**出队 资源池空会将出队线程挂起*/</span><br><span class="line">public E poll() throws InterruptedException &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">while(nItems == 0) </span><br><span class="line">notEmpty.await();</span><br><span class="line">E e = dequeue();</span><br><span class="line">System.out.println(&quot;学生出队，当前池中有 &quot; + nItems + &quot; 名同学&quot; );</span><br><span class="line">return e;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**是否满*/</span><br><span class="line">public boolean isFull() &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">return nItems == MaxSize ? true : false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**判断是否为空*/</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">return nItems == 0 ? true : false;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**返回队列中元素个数*/</span><br><span class="line">public int size() &#123;</span><br><span class="line">final ReentrantLock lock = this.lock;</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">return this.nItems;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class PM &#123;</span><br><span class="line"></span><br><span class="line">private Pool&lt;Student&gt; pools = new Pool&lt;Student&gt;(1000);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">PM pm = new PM();</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(6); </span><br><span class="line">executor.execute(pm.new consume());</span><br><span class="line">executor.execute(pm.new consume());</span><br><span class="line">executor.execute(pm.new consume());</span><br><span class="line">executor.execute(pm.new produce());</span><br><span class="line">executor.execute(pm.new produce());</span><br><span class="line">executor.execute(pm.new produce());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> class produce implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">pools.offer(new Student());</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class consume implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">pools.poll();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://img.blog.csdn.net/20160110142045609" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生产者和消费者模型是操作系统中经典的同步问题。该问题最早由Dijkstra提出，用以演示它提出的信号量机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典的生产者和消费者模型的描述是：&lt;/strong&gt;有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://hustchai.github.io/cjy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之volatile</title>
    <link href="https://hustchai.github.io/cjy.github.io/2017/12/09/Java%E5%B9%B6%E5%8F%91%E4%B9%8Bvolatile/"/>
    <id>https://hustchai.github.io/cjy.github.io/2017/12/09/Java并发之volatile/</id>
    <published>2017-12-09T10:40:04.000Z</published>
    <updated>2017-12-09T11:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>volatile有两个特性</p><ul><li>确保volatile修饰的变量对所有线程可见。</li><li>禁止指令重排</li></ul><p>##确保volatile修饰的变量对所有线程可见</p><p>为了解释第一个特性，首先我们要知道java内存模型，java内存逻辑上分为<strong>工作内存和主内存</strong>（这里内存的定义和我们平常所说的java内存分为堆、栈、方法区等并不冲突）</p><p>java内存模型规定所有的变量都存在主内存中，每条线程还有自己的工作内存，<strong>工作内存中保存了该线程使用到变量的主内存的副本拷贝</strong>，线程对所有变量的修改都应该在工作内存中，而不能直接修改主内存中的变量。不同线程之间不互相操作对方工作内存中的变量，<strong>线程间变量之间的消息传递必须通过主内存。</strong></p><p><img src="http://img.blog.csdn.net/20160108114707459" alt="java线程、工作内存、主内存之间的关系"><br>           图1：java线程、工作内存、主内存之间的关系</p><p>现有一业务场景如下：<br>主内存中有一个共享变量i,线程A的主要任务是修改共享变量i的值，线程B的主要任务是读取共享变量i的值。如果不对程序做同步处理，某时刻线程A将共享变量i的值修改为2。上文我们说到线程修改的是工作内存中主内存的副本的值，线程A修改共享变量i的值后还未将最新值同步回主内存中。而此时线程B读取了共享变量i的值。因此在并发的时候就可能出现问题。</p><p>如果将共享变量用volatitle修饰后，就可以避免这样的问题。现在我们来看看，volatile是怎么保证对所有线程的可见性的。</p><p>依然还是上面的业务场景。在线程A修改了共享变量i的值后，由于此变量被volatile修饰，所有虚拟机会将线程A中共享变量i的值<strong>立即同步</strong>回主内存中。线程B在读取共享变量i的值时，不会选择线程B工作内存中的副本值，而会重新读取主内存中共享变量i的值。所以volatile保证了对所有线程的可见性。理解volatile可见性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步操作。</p><p>##禁止指令重排。<br>指令重排是指编译器和处理器为了提高程序性能而对指令序列进行重新排序的一种手段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">int a = 0;</span><br><span class="line">int i = 0;</span><br><span class="line">boolean flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">a = 1;</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">if(flag) </span><br><span class="line">i = a + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag是一个标记，用来标记变量a是否已经被修改。假设有线程A和线程B,A执行write操作，B执行read操作，那么B在执行i = a + 1操作时是否能看到线程A在write操作中对a的修改呢？<br><strong>不一定</strong><br>处理器和编译器可能对程序指令进行重排序，程序执行顺序可能为<br><img src="http://img.blog.csdn.net/20160108123920392" alt="这里写图片描述"><br>在这里多线程程序的语义被重排序破坏了，故在写多线程程序时不能认为写在前面的代码就一定会比写在后面的代码先执行。那程序执行的顺序应该按照什么规则进行判断呢？从JDK5开始，java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。</p><ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁,而“后面”指时间上的先后顺序。</li><li>Volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li><li>线程启动规则:Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</li><li>传递性：如果A happens-before B,且Bhappens-before C那么A happens-before C。</li></ul><p>当变量被volatile修饰后，虚拟机通过在volatile加入内存壁障的手法从而达到禁止指令重排序的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;volatile有两个特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保volatile修饰的变量对所有线程可见。&lt;/li&gt;
&lt;li&gt;禁止指令重排&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##确保volatile修饰的变量对所有线程可见&lt;/p&gt;
&lt;p&gt;为了解释第一个特性，首先我们要知道java内存模
      
    
    </summary>
    
    
      <category term="java" scheme="https://hustchai.github.io/cjy.github.io/tags/java/"/>
    
  </entry>
  
</feed>
